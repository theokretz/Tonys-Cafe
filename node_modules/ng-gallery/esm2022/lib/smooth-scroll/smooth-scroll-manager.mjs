import { Inject, Optional, Injectable } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType } from '@angular/cdk/platform';
import { Observable, Subject, fromEvent, merge, of, expand, finalize, take, takeUntil, takeWhile } from 'rxjs';
import BezierEasing from './bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/platform";
// @dynamic
class SmoothScrollManager {
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance?.now?.bind(this._w.performance) || Date.now;
    }
    constructor(_document, customDefaultOptions, _platform) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...customDefaultOptions,
        };
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => subscriber.next(context));
        });
    }
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        const destroyed = this._initSmoothScroll(el);
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(resolve => {
            // Scroll each step recursively
            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();
        });
    }
    /**
     * Dismiss an ongoing scroll
     * @param el
     */
    dismissOngoingScroll(el) {
        this._onGoingScrolls.get(el)?.next();
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        if (this._platform.isBrowser) {
            const el = this._getElement(scrollable);
            const isRtl = getComputedStyle(el).direction === 'rtl';
            const rtlScrollAxisType = getRtlScrollAxisType();
            const options = {
                ...this._defaultOptions,
                ...customOptions,
                ...{
                    // Rewrite start & end offsets as right or left offsets.
                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
                }
            };
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this._getElement(scrollable);
        const targetEl = this._getElement(target, scrollableEl);
        const options = {
            ...customOptions,
            ...{
                left: targetEl.offsetLeft + (customOptions.left || 0),
                top: targetEl.offsetTop + (customOptions.top || 0)
            }
        };
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.1", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.1.1", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' }); }
}
export { SmoothScrollManager };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.1", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SMOOTH_SCROLL_OPTIONS]
                }] }, { type: i1.Platform }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ2FsbGVyeS9zcmMvbGliL3Ntb290aC1zY3JvbGwvc21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBYyxNQUFNLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxvQkFBb0IsRUFBK0IsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRixPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBYyxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNILE9BQU8sWUFBWSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFDTCxxQkFBcUIsRUFLdEIsTUFBTSx1QkFBdUIsQ0FBQzs7O0FBRS9CLFdBQVc7QUFDWCxNQUdhLG1CQUFtQjtJQVc5QixJQUFZLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVksSUFBSTtRQUNkLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDekUsQ0FBQztJQUVELFlBQXNDLFNBQW1CLEVBQ0Ysb0JBQTJDLEVBQzlFLFNBQW1CO1FBRkQsY0FBUyxHQUFULFNBQVMsQ0FBVTtR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Z0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDckUsTUFBTSxPQUFPLEdBQTBCO1lBQ3JDLEdBQUcsYUFBYTtZQUNoQixHQUFHO2dCQUNELElBQUksRUFBRSxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7Z0JBQ3JELEdBQUcsRUFBRSxRQUFRLENBQUMsU0FBUyxHQUFHLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7YUFDbkQ7U0FDRixDQUFDO1FBQ0YsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDN0UsQ0FBQzs4R0FoT1UsbUJBQW1CLGtCQXNCVixRQUFRLGFBQ0kscUJBQXFCO2tIQXZCMUMsbUJBQW1CLGNBRmxCLE1BQU07O1NBRVAsbUJBQW1COzJGQUFuQixtQkFBbUI7a0JBSC9CLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkF1QmMsTUFBTTsyQkFBQyxRQUFROzswQkFDZixRQUFROzswQkFBSSxNQUFNOzJCQUFDLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgT3B0aW9uYWwsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBjb2VyY2VFbGVtZW50IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHsgZ2V0UnRsU2Nyb2xsQXhpc1R5cGUsIFBsYXRmb3JtLCBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IF9Cb3R0b20sIF9MZWZ0LCBfUmlnaHQsIF9Ub3AsIF9XaXRob3V0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmliZXIsIGZyb21FdmVudCwgbWVyZ2UsIG9mLCBleHBhbmQsIGZpbmFsaXplLCB0YWtlLCB0YWtlVW50aWwsIHRha2VXaGlsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgQmV6aWVyRWFzaW5nIGZyb20gJy4vYmV6aWVyLWVhc2luZyc7XHJcbmltcG9ydCB7XHJcbiAgU01PT1RIX1NDUk9MTF9PUFRJT05TLFxyXG4gIFNtb290aFNjcm9sbEVsZW1lbnQsXHJcbiAgU21vb3RoU2Nyb2xsU3RlcCxcclxuICBTbW9vdGhTY3JvbGxUb0VsZW1lbnRPcHRpb25zLFxyXG4gIFNtb290aFNjcm9sbFRvT3B0aW9uc1xyXG59IGZyb20gJy4vc21vb3RoLXNjcm9sbC5tb2RlbCc7XHJcblxyXG4vLyBAZHluYW1pY1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTbW9vdGhTY3JvbGxNYW5hZ2VyIHtcclxuXHJcbiAgLy8gRGVmYXVsdCBvcHRpb25zXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfZGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucztcclxuXHJcbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG9uZ29pbmcgU21vb3RoU2Nyb2xsIGZ1bmN0aW9ucywgc28gdGhleSBjYW4gYmUgaGFuZGxlZCBpbiBjYXNlIG9mIGR1cGxpY2F0aW9uLlxyXG4gIC8vIEVhY2ggc2Nyb2xsZWQgZWxlbWVudCBnZXRzIGEgZGVzdHJveWVyIHN0cmVhbSB3aGljaCBnZXRzIGRlbGV0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gIC8vIFB1cnBvc2U6IElmIHVzZXIgY2FsbGVkIGEgc2Nyb2xsIGZ1bmN0aW9uIGFnYWluIG9uIHRoZSBzYW1lIGVsZW1lbnQgYmVmb3JlIHRoZSBzY3JvbGxzIGNvbXBsZXRlcyxcclxuICAvLyBpdCBjYW5jZWxzIHRoZSBvbmdvaW5nIHNjcm9sbCBhbmQgc3RhcnRzIGEgbmV3IG9uZVxyXG4gIHByaXZhdGUgX29uR29pbmdTY3JvbGxzID0gbmV3IE1hcDxIVE1MRWxlbWVudCwgU3ViamVjdDx2b2lkPj4oKTtcclxuXHJcbiAgcHJpdmF0ZSBnZXQgX3coKTogV2luZG93IHtcclxuICAgIHJldHVybiB0aGlzLl9kb2N1bWVudC5kZWZhdWx0VmlldztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWluZyBtZXRob2RcclxuICAgKi9cclxuICBwcml2YXRlIGdldCBfbm93KCk6ICgpID0+IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fdy5wZXJmb3JtYW5jZT8ubm93Py5iaW5kKHRoaXMuX3cucGVyZm9ybWFuY2UpIHx8IERhdGUubm93O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IERvY3VtZW50LFxyXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoU01PT1RIX1NDUk9MTF9PUFRJT05TKSBjdXN0b21EZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zLFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX3BsYXRmb3JtOiBQbGF0Zm9ybSkge1xyXG4gICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgIGR1cmF0aW9uOiA0NjgsXHJcbiAgICAgIGVhc2luZzoge1xyXG4gICAgICAgIHgxOiAwLjQyLFxyXG4gICAgICAgIHkxOiAwLFxyXG4gICAgICAgIHgyOiAwLjU4LFxyXG4gICAgICAgIHkyOiAxXHJcbiAgICAgIH0sXHJcbiAgICAgIC4uLmN1c3RvbURlZmF1bHRPcHRpb25zLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc2Nyb2xsRWxlbWVudChlbDogSFRNTEVsZW1lbnQsIHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBlbC5zY3JvbGxMZWZ0ID0geDtcclxuICAgIGVsLnNjcm9sbFRvcCA9IHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgZ2l2ZW4gcGFyYW1ldGVyIG9mIHR5cGUgSFRNTEVsZW1lbnQsIEVsZW1lbnRSZWYgb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRFbGVtZW50KGVsOiBIVE1MRWxlbWVudCB8IEVsZW1lbnRSZWYgfCBzdHJpbmcsIHBhcmVudD86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xyXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIChwYXJlbnQgfHwgdGhpcy5fZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZXJjZUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KGVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGEgZGVzdHJveWVyIHN0cmVhbSwgcmUtaW5pdGlhbGl6ZXMgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2luaXRTbW9vdGhTY3JvbGwoZWw6IEhUTUxFbGVtZW50KTogU3ViamVjdDx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5fb25Hb2luZ1Njcm9sbHMuaGFzKGVsKSkge1xyXG4gICAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5nZXQoZWwpLm5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9vbkdvaW5nU2Nyb2xscy5zZXQoZWwsIG5ldyBTdWJqZWN0PHZvaWQ+KCkpLmdldChlbCkhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHNtb290aCBzY3JvbGwgaGFzIHJlYWNoZWQsIGNsZWFucyB1cCB0aGUgc21vb3RoIHNjcm9sbCBzdHJlYW0gYW5kIHJlc29sdmVzIGl0cyBwcm9taXNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaXNGaW5pc2hlZChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwLCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4sIHJlc29sdmU6ICgpID0+IHZvaWQpOiBib29sZWFuIHtcclxuICAgIGlmIChjb250ZXh0LmN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY29udGV4dC5jdXJyZW50WSAhPT0gY29udGV4dC55KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveWVkLm5leHQoKTtcclxuICAgIHJlc29sdmUoKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlcm1pbmF0ZXMgYW4gb25nb2luZyBzbW9vdGggc2Nyb2xsXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW50ZXJydXB0ZWQoZWw6IEhUTUxFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiBPYnNlcnZhYmxlPEV2ZW50IHwgdm9pZD4ge1xyXG4gICAgcmV0dXJuIG1lcmdlKFxyXG4gICAgICBmcm9tRXZlbnQoZWwsICd3aGVlbCcsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgZnJvbUV2ZW50KGVsLCAndG91Y2htb3ZlJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICBkZXN0cm95ZWRcclxuICAgICkucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgdGhlIGRlc3Ryb3llciBmdW5jdGlvbiwgcnVucyBpZiB0aGUgc21vb3RoIHNjcm9sbCBoYXMgZmluaXNoZWQgb3IgaW50ZXJydXB0ZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9kZXN0cm95KGVsOiBIVE1MRWxlbWVudCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+KTogdm9pZCB7XHJcbiAgICBkZXN0cm95ZWQuY29tcGxldGUoKTtcclxuICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmRlbGV0ZShlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGZ1bmN0aW9uIGNhbGxlZCByZWN1cnNpdmVseSB0aGF0LCBnaXZlbiBhIGNvbnRleHQsIHN0ZXBzIHRocm91Z2ggc2Nyb2xsaW5nXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc3RlcChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKTogT2JzZXJ2YWJsZTxTbW9vdGhTY3JvbGxTdGVwPiB7XHJcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8U21vb3RoU2Nyb2xsU3RlcD4pID0+IHtcclxuICAgICAgbGV0IGVsYXBzZWQgPSAodGhpcy5fbm93KCkgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBjb250ZXh0LmR1cmF0aW9uO1xyXG5cclxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcclxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XHJcblxyXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5lYXNpbmcoZWxhcHNlZCk7XHJcblxyXG4gICAgICBjb250ZXh0LmN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XHJcbiAgICAgIGNvbnRleHQuY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcclxuXHJcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQoY29udGV4dC5zY3JvbGxhYmxlLCBjb250ZXh0LmN1cnJlbnRYLCBjb250ZXh0LmN1cnJlbnRZKTtcclxuICAgICAgLy8gUHJvY2VlZCB0byB0aGUgc3RlcFxyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc3Vic2NyaWJlci5uZXh0KGNvbnRleHQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfYXBwbHlTY3JvbGxUb09wdGlvbnMoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghb3B0aW9ucy5kdXJhdGlvbikge1xyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGVsLCBvcHRpb25zLmxlZnQsIG9wdGlvbnMudG9wKTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWxpemUgYSBkZXN0cm95ZXIgc3RyZWFtLCByZWluaXRpYWxpemUgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxyXG4gICAgY29uc3QgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+ID0gdGhpcy5faW5pdFNtb290aFNjcm9sbChlbCk7XHJcblxyXG4gICAgY29uc3QgY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCA9IHtcclxuICAgICAgc2Nyb2xsYWJsZTogZWwsXHJcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5fbm93KCksXHJcbiAgICAgIHN0YXJ0WDogZWwuc2Nyb2xsTGVmdCxcclxuICAgICAgc3RhcnRZOiBlbC5zY3JvbGxUb3AsXHJcbiAgICAgIHg6IG9wdGlvbnMubGVmdCA9PSBudWxsID8gZWwuc2Nyb2xsTGVmdCA6IH5+b3B0aW9ucy5sZWZ0LFxyXG4gICAgICB5OiBvcHRpb25zLnRvcCA9PSBudWxsID8gZWwuc2Nyb2xsVG9wIDogfn5vcHRpb25zLnRvcCxcclxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXHJcbiAgICAgIGVhc2luZzogQmV6aWVyRWFzaW5nKG9wdGlvbnMuZWFzaW5nLngxLCBvcHRpb25zLmVhc2luZy55MSwgb3B0aW9ucy5lYXNpbmcueDIsIG9wdGlvbnMuZWFzaW5nLnkyKVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIC8vIFNjcm9sbCBlYWNoIHN0ZXAgcmVjdXJzaXZlbHlcclxuICAgICAgb2YobnVsbCkucGlwZShcclxuICAgICAgICBleHBhbmQoKCkgPT4gdGhpcy5fc3RlcChjb250ZXh0KS5waXBlKFxyXG4gICAgICAgICAgdGFrZVdoaWxlKChjdXJyQ29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCkgPT4gdGhpcy5faXNGaW5pc2hlZChjdXJyQ29udGV4dCwgZGVzdHJveWVkLCByZXNvbHZlKSlcclxuICAgICAgICApKSxcclxuICAgICAgICB0YWtlVW50aWwodGhpcy5faW50ZXJydXB0ZWQoZWwsIGRlc3Ryb3llZCkpLFxyXG4gICAgICAgIGZpbmFsaXplKCgpID0+IHRoaXMuX2Rlc3Ryb3koZWwsIGRlc3Ryb3llZCkpXHJcbiAgICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc21pc3MgYW4gb25nb2luZyBzY3JvbGxcclxuICAgKiBAcGFyYW0gZWxcclxuICAgKi9cclxuICBkaXNtaXNzT25nb2luZ1Njcm9sbChlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmdldChlbCk/Lm5leHQoKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy4gVGhpcyBpcyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzY3JvbGxUb1xyXG4gICAqIG1ldGhvZCwgc2luY2UgYnJvd3NlcnMgYXJlIG5vdCBjb25zaXN0ZW50IGFib3V0IHdoYXQgc2Nyb2xsTGVmdCBtZWFucyBpbiBSVEwuIEZvciB0aGlzIG1ldGhvZFxyXG4gICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcclxuICAgKiBvZiB0aGUgbGF5b3V0IGRpcmVjdGlvbi4gc3RhcnQgYW5kIGVuZCByZWZlciB0byBsZWZ0IGFuZCByaWdodCBpbiBhbiBMVFIgY29udGV4dCBhbmQgdmljZS12ZXJzYVxyXG4gICAqIGluIGFuIFJUTCBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgKiBAcGFyYW0gY3VzdG9tT3B0aW9ucyBzcGVjaWZpZWQgdGhlIG9mZnNldHMgdG8gc2Nyb2xsIHRvLlxyXG4gICAqL1xyXG4gIHNjcm9sbFRvKHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xyXG4gICAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xyXG4gICAgICBjb25zdCBpc1J0bDogYm9vbGVhbiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XHJcbiAgICAgIGNvbnN0IHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSA9IGdldFJ0bFNjcm9sbEF4aXNUeXBlKCk7XHJcblxyXG4gICAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgICAgLi4uKHRoaXMuX2RlZmF1bHRPcHRpb25zIGFzIF9XaXRob3V0PF9Cb3R0b20gJiBfVG9wPiksXHJcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcclxuICAgICAgICAuLi4oe1xyXG4gICAgICAgICAgLy8gUmV3cml0ZSBzdGFydCAmIGVuZCBvZmZzZXRzIGFzIHJpZ2h0IG9yIGxlZnQgb2Zmc2V0cy5cclxuICAgICAgICAgIGxlZnQ6IGN1c3RvbU9wdGlvbnMubGVmdCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5lbmQgOiBjdXN0b21PcHRpb25zLnN0YXJ0KSA6IGN1c3RvbU9wdGlvbnMubGVmdCxcclxuICAgICAgICAgIHJpZ2h0OiBjdXN0b21PcHRpb25zLnJpZ2h0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLnN0YXJ0IDogY3VzdG9tT3B0aW9ucy5lbmQpIDogY3VzdG9tT3B0aW9ucy5yaWdodFxyXG4gICAgICAgIH0gYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUmV3cml0ZSB0aGUgYm90dG9tIG9mZnNldCBhcyBhIHRvcCBvZmZzZXQuXHJcbiAgICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbT4gJiBfVG9wKS50b3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQgLSBvcHRpb25zLmJvdHRvbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmV3cml0ZSB0aGUgcmlnaHQgb2Zmc2V0IGFzIGEgbGVmdCBvZmZzZXQuXHJcbiAgICAgIGlmIChpc1J0bCAmJiBydGxTY3JvbGxBeGlzVHlwZSAhPT0gUnRsU2Nyb2xsQXhpc1R5cGUuTk9STUFMKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfTGVmdD4gJiBfUmlnaHQpLnJpZ2h0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMubGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodCA/IC1vcHRpb25zLnJpZ2h0IDogb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X1JpZ2h0PiAmIF9MZWZ0KS5sZWZ0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNjcm9sbFRvT3B0aW9ucyhlbCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgdG8gZWxlbWVudCBieSByZWZlcmVuY2Ugb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBzY3JvbGxUb0VsZW1lbnQoc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgdGFyZ2V0OiBTbW9vdGhTY3JvbGxFbGVtZW50LCBjdXN0b21PcHRpb25zOiBTbW9vdGhTY3JvbGxUb0VsZW1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHNjcm9sbGFibGVFbDogSFRNTEVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xyXG4gICAgY29uc3QgdGFyZ2V0RWw6IEhUTUxFbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCh0YXJnZXQsIHNjcm9sbGFibGVFbCk7XHJcbiAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXHJcbiAgICAgIC4uLntcclxuICAgICAgICBsZWZ0OiB0YXJnZXRFbC5vZmZzZXRMZWZ0ICsgKGN1c3RvbU9wdGlvbnMubGVmdCB8fCAwKSxcclxuICAgICAgICB0b3A6IHRhcmdldEVsLm9mZnNldFRvcCArIChjdXN0b21PcHRpb25zLnRvcCB8fCAwKVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRhcmdldEVsID8gdGhpcy5zY3JvbGxUbyhzY3JvbGxhYmxlRWwsIG9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==