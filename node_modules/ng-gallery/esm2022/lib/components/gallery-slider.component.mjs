import { Component, Input, Output, EventEmitter, ViewChild, ViewChildren, QueryList, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { from, distinctUntilChanged, fromEvent, mergeMap, startWith, tap, debounceTime, filter, takeUntil, switchMap, Observable, Subject, EMPTY, animationFrameScheduler } from 'rxjs';
import { SlidingDirection } from '../models/constants';
import { HorizontalAdapter, VerticalAdapter } from './adapters';
import { resizeObservable } from '../utils/resize-observer';
import { GalleryItemComponent } from './gallery-item.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/platform";
import * as i2 from "../smooth-scroll";
import * as i3 from "../services/gallery.service";
import * as i4 from "@angular/common";
class GallerySliderComponent {
    get slider() {
        return this.sliderEl.nativeElement;
    }
    constructor(_el, _cd, _zone, _platform, _smoothScroll, _gallery) {
        this._el = _el;
        this._cd = _cd;
        this._zone = _zone;
        this._platform = _platform;
        this._smoothScroll = _smoothScroll;
        this._gallery = _gallery;
        this.scrollHandler$ = new Subject();
        this.visibleElements = new Map();
        this._destroyed$ = new Subject();
        /** Stream that emits when item is clicked */
        this.itemClick = new EventEmitter();
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
        this.items = new QueryList();
        this.scrollHandler$.pipe(debounceTime(0, animationFrameScheduler), switchMap(({ value, behavior }) => {
            this._gallery.debugConsole('[Gallery scrollHandler$] ', this.slider.style.scrollSnapType);
            this.slider.style.scrollSnapType = 'unset';
            const el = this.items.get(value)?.element;
            this._gallery.debugConsole('🤯 [Gallery scrollHandler$] scrollSnapType = unset, scrollTo element', !!el);
            if (el) {
                this.slider.classList.add('g-scrolling');
                const pos = this.adapter.getScrollToValue(el, behavior || this.config.scrollBehavior);
                const index = +this.items.get(value)?.element.getAttribute('galleryIndex');
                this._gallery.debugConsole(`🚀 [Gallery scrollHandler$] Scroll start ===> index: ${index}, position:`, pos);
                this._gallery.debugConsole(`🚀 [Gallery scrollHandler$] slider scrollable`, this.adapter.scrollValue);
                return from(this._smoothScroll.scrollTo(this.slider, pos)).pipe(tap(() => {
                    // Reset viewport properties on scroll end
                    this._isPanning = false;
                    this.slider.classList.remove('g-scrolling');
                    this.slider.style.scrollSnapType = this.adapter.scrollSnapType;
                    this._gallery.debugConsole('✅ [Gallery scrollHandler$] Scroll end');
                }));
            }
            this._gallery.debugConsole('😡 [Gallery scrollHandler$] Scroll element was not found!');
            return EMPTY;
        }), takeUntil(this._destroyed$)).subscribe();
    }
    ngOnChanges(changes) {
        if (changes.config) {
            if (changes.config.currentValue?.slidingDirection !== changes.config.previousValue?.slidingDirection) {
                switch (this.config.slidingDirection) {
                    case SlidingDirection.Horizontal:
                        this.adapter = new HorizontalAdapter(this.slider, this.config);
                        break;
                    case SlidingDirection.Vertical:
                        this.adapter = new VerticalAdapter(this.slider, this.config);
                        break;
                }
                if (this._platform.isBrowser) {
                    if (!changes.config.firstChange) {
                        requestAnimationFrame(() => {
                            // Keep the correct sliding position when direction changes
                            this.scrollToIndex(this.state.currIndex, 'auto');
                        });
                    }
                    // Reactivate gestures
                    this.enableDisableGestures();
                }
            }
            if (this._platform.isBrowser && !changes.config.firstChange) {
                if (changes.config.currentValue?.mouseSlidingDisabled !== changes.config.previousValue?.mouseSlidingDisabled) {
                    this.enableDisableGestures();
                }
            }
        }
        // Scroll to current index
        if (this._platform.isBrowser && changes.state && changes.state.currentValue?.currIndex !== changes.state.previousValue?.currIndex) {
            requestAnimationFrame(() => {
                this.scrollToIndex(this.state.currIndex, changes.state.firstChange ? 'auto' : this.state.behavior);
            });
        }
    }
    ngOnInit() {
        if (this._platform.isBrowser) {
            this._zone.runOutsideAngular(() => {
                // We need to set the visibleElements in the viewport using intersection observer
                this.createIntersectionObserver(this.slider).pipe(tap((entry) => {
                    entry.target.classList.toggle('g-item-visible', entry.isIntersecting);
                    if (entry.isIntersecting) {
                        this.visibleElements.set(entry.target, entry);
                    }
                    else {
                        this.visibleElements.delete(entry.target);
                    }
                }), takeUntil(this._destroyed$)).subscribe();
                // Subscribe to slider scroll event
                fromEvent(this.slider, 'scroll', { passive: true }).pipe(debounceTime(50), filter(() => !this._isPanning), tap(() => this.onViewportScroll()), takeUntil(this._destroyed$)).subscribe();
                // Detect if the size of the slider has changed detecting current index on scroll
                resizeObservable(this._el.nativeElement).pipe(debounceTime(this.config.resizeDebounceTime), tap(([entry]) => this.onHostResize(entry)), takeUntil(this._destroyed$)).subscribe();
            });
        }
    }
    ngAfterViewInit() {
        if (this._platform.isBrowser) {
            this.items.notifyOnChanges();
            this.items.changes.pipe(startWith(null), tap(() => {
                // Disconnect all and reconnect later
                this.visibleElements.forEach((item) => {
                    this.intersectionObserver.unobserve(item.target);
                });
                // Connect with the new items
                this.items.toArray().map((item) => {
                    this.intersectionObserver.observe(item.element);
                });
            }), takeUntil(this._destroyed$)).subscribe();
        }
    }
    ngAfterViewChecked() {
        if (this.config.itemAutosize && this._platform.isBrowser) {
            this.slider.style.setProperty('--slider-centralize-start-size', this.adapter.getCentralizerStartSize() + 'px');
            this.slider.style.setProperty('--slider-centralize-end-size', this.adapter.getCentralizerEndSize() + 'px');
        }
    }
    ngOnDestroy() {
        this._destroyed$.next();
        this._destroyed$.complete();
        this.deactivateGestures();
    }
    trackByFn(index, item) {
        return item.type;
    }
    onHostResize(entry) {
        const width = Math.ceil(entry.contentRect.width);
        const height = Math.ceil(entry.contentRect.height);
        this.slider.style.width = `${width}px`;
        this.slider.style.height = `${height}px`;
        this.scrollToIndex(this.state.currIndex, 'auto');
        // Detect changes on gallery-item components to re-calculate item size
        this._cd.detectChanges();
        this._gallery.debugConsole('🦐 [Gallery OnHostResize]: set viewport width to absolute number');
    }
    onViewportScroll() {
        // Check if scrolled item is great enough to navigate
        const currElement = this.items.get(this.state.currIndex)?.element;
        const elementAtCenter = this.getElementFromViewportCenter();
        if (elementAtCenter) {
            // Check if the gallery-item element is not the active element
            if (elementAtCenter !== currElement) {
                this.tryScrollToElement(elementAtCenter);
            }
        }
        else {
            this._gallery.debugConsole('⁉ [Gallery onViewportScroll]: No center element was found');
            this.visibleElements.forEach((entry) => {
                this.tryScrollToElement(entry.target);
            });
        }
    }
    tryScrollToElement(elementAtCenter) {
        const allowedMargin = 10;
        const offsetDiff = (this.adapter.clientSize - this.adapter.getClientSize(elementAtCenter)) / 2;
        const rangeStart = this.adapter.scrollValue + offsetDiff;
        const rangeEnd = this.adapter.scrollValue + this.adapter.clientSize - offsetDiff;
        const elStart = this.adapter.getOffsetSize(elementAtCenter);
        const elEnd = elStart + this.adapter.getClientSize(elementAtCenter);
        const isStart = rangeStart + allowedMargin >= elStart && rangeStart - allowedMargin <= elStart;
        const isEnd = rangeEnd + allowedMargin >= elEnd && rangeEnd - allowedMargin <= elEnd;
        // Reset position
        this.slider.style.scrollSnapType = this.adapter.scrollSnapType;
        // Check if element is within the detection range
        if (isStart && isEnd) {
            // If element is within the range set it as the active gallery item
            this._gallery.debugConsole('🍄 [Gallery onViewportScroll]: Set active gallery item');
            const index = +elementAtCenter.getAttribute('galleryIndex');
            this._zone.run(() => this._gallery.ref(this.galleryId).set(index, 'smooth'));
        }
    }
    scrollToIndex(value, behavior, onEnd) {
        this.scrollHandler$.next({ value, behavior, onEnd });
    }
    enableDisableGestures() {
        // Enable/Disable mouse sliding on desktop browser only
        if (!this._platform.IOS && !this._platform.ANDROID) {
            if (!this.config.mouseSlidingDisabled) {
                this.activateGestures();
            }
            else {
                this.deactivateGestures();
            }
        }
    }
    activateGestures() {
        if (typeof Hammer !== 'undefined') {
            // Destroy hammer if a previous instance was created
            this.deactivateGestures();
            const direction = this.adapter.panDirection;
            // Activate gestures
            this._zone.runOutsideAngular(() => {
                this._hammer = new Hammer(this._el.nativeElement, { inputClass: Hammer.MouseInput });
                this._hammer.get('pan').set({ direction });
                let panOffset;
                // Set panOffset for sliding on pan start event
                this._hammer.on('panstart', () => {
                    this._smoothScroll.dismissOngoingScroll(this.slider);
                    panOffset = this.adapter.scrollValue;
                    // Disable scroll-snap-type functionality
                    this.slider.style.scrollSnapType = 'unset';
                    this.slider.classList.add('g-sliding');
                    this._isPanning = true;
                });
                this._hammer.on('panmove', (e) => this.slider.scrollTo(this.adapter.getPanValue(panOffset, e, 'auto')));
                this._hammer.on('panend', (e) => this.onPanEnd(e));
            });
        }
    }
    deactivateGestures() {
        this._hammer?.destroy();
    }
    onPanEnd(e) {
        this._gallery.debugConsole('🖱️ [Gallery]: onPanEnd', e);
        this.slider.classList.remove('g-sliding');
        const delta = this.adapter.getPanDelta(e);
        const velocity = this.adapter.getPanVelocity(e);
        const galleryRef = this._gallery.ref(this.galleryId);
        this._zone.run(() => {
            // Check if scrolled item is great enough to navigate
            const currElement = this.items.get(this.state.currIndex)?.element;
            // Find the gallery item element in the center elements
            const elementAtCenter = this.getElementFromViewportCenter();
            // Check if center item can be taken from element using
            if (elementAtCenter && elementAtCenter !== currElement) {
                const index = +elementAtCenter.getAttribute('galleryIndex');
                this.scrollToIndex(index, 'smooth');
                return;
            }
            // Check if delta is great enough to navigate
            if (Math.abs(delta) > (currElement.clientWidth || this.adapter.clientSize) / 2) {
                return delta > 0 ? galleryRef.prev('smooth', false) : galleryRef.next('smooth', false);
            }
            // Check if velocity is great enough to navigate
            if (Math.abs(velocity) > 0.3) {
                return velocity > 0 ? galleryRef.prev('smooth', false) : galleryRef.next('smooth', false);
            }
            // Reset position to the current index
            this.scrollToIndex(this.state.currIndex, 'smooth');
        });
    }
    getElementFromViewportCenter() {
        // Get slider position relative to the document
        const sliderRect = this.slider.getBoundingClientRect();
        // Try look for the center item using `elementsFromPoint` function
        const centerElements = document.elementsFromPoint(sliderRect.x + (sliderRect.width / 2), sliderRect.y + (sliderRect.height / 2));
        // Find the gallery item element in the center elements
        const element = centerElements.find((element) => element.localName === 'gallery-item' && element.getAttribute('galleryId') === this.galleryId);
        this._gallery.debugConsole('🪟 [Gallery]: getElementFromViewportCenter', element);
        return element;
    }
    createIntersectionObserver(slider) {
        return new Observable((observer) => {
            this.intersectionObserver = new IntersectionObserver((entries) => observer.next(entries), { root: slider });
            return () => this.intersectionObserver.disconnect();
        }).pipe(mergeMap((entries) => entries), distinctUntilChanged());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.1", ngImport: i0, type: GallerySliderComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.Platform }, { token: i2.SmoothScrollManager }, { token: i3.Gallery }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.1", type: GallerySliderComponent, isStandalone: true, selector: "gallery-slider", inputs: { galleryId: "galleryId", state: "state", config: "config" }, outputs: { itemClick: "itemClick", error: "error" }, viewQueries: [{ propertyName: "sliderEl", first: true, predicate: ["slider"], descendants: true, static: true }, { propertyName: "items", predicate: GalleryItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #slider
         class="g-slider"
         [attr.centralised]="config.itemAutosize">
      <div class="g-slider-content">
        <gallery-item *ngFor="let item of state.items; trackBy: trackByFn; index as i"
                      [attr.galleryId]="galleryId"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      [count]="state.items.length"
                      (click)="itemClick.emit(i)"
                      (error)="error.emit({ itemIndex: i, error: $event })">
        </gallery-item>
      </div>
    </div>
    <ng-content></ng-content>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: GalleryItemComponent, selector: "gallery-item", inputs: ["config", "index", "count", "currIndex", "type", "data"], outputs: ["error"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { GallerySliderComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.1", ngImport: i0, type: GallerySliderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gallery-slider',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <div #slider
         class="g-slider"
         [attr.centralised]="config.itemAutosize">
      <div class="g-slider-content">
        <gallery-item *ngFor="let item of state.items; trackBy: trackByFn; index as i"
                      [attr.galleryId]="galleryId"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      [count]="state.items.length"
                      (click)="itemClick.emit(i)"
                      (error)="error.emit({ itemIndex: i, error: $event })">
        </gallery-item>
      </div>
    </div>
    <ng-content></ng-content>
  `,
                    standalone: true,
                    imports: [CommonModule, GalleryItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.Platform }, { type: i2.SmoothScrollManager }, { type: i3.Gallery }]; }, propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], error: [{
                type: Output
            }], sliderEl: [{
                type: ViewChild,
                args: ['slider', { static: true }]
            }], items: [{
                type: ViewChildren,
                args: [GalleryItemComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2FsbGVyeS1zbGlkZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ2FsbGVyeS9zcmMvbGliL2NvbXBvbmVudHMvZ2FsbGVyeS1zbGlkZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBTVosU0FBUyxFQUNULFlBQVksRUFJWixTQUFTLEVBRVQsdUJBQXVCLEVBQ3hCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvQyxPQUFPLEVBQ0wsSUFBSSxFQUNKLG9CQUFvQixFQUNwQixTQUFTLEVBQ1QsUUFBUSxFQUNSLFNBQVMsRUFDVCxHQUFHLEVBQ0gsWUFBWSxFQUNaLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFDVixPQUFPLEVBRVAsS0FBSyxFQUNMLHVCQUF1QixFQUN4QixNQUFNLE1BQU0sQ0FBQztBQUlkLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBaUIsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRS9FLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzVELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7Ozs7QUFVaEUsTUEwQmEsc0JBQXNCO0lBcUNqQyxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDO0lBQ3JDLENBQUM7SUFFRCxZQUFvQixHQUE0QixFQUM1QixHQUFzQixFQUN0QixLQUFhLEVBQ2IsU0FBbUIsRUFDbkIsYUFBa0MsRUFDbEMsUUFBaUI7UUFMakIsUUFBRyxHQUFILEdBQUcsQ0FBeUI7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QkFBYixLQUFLO2dCQUdHLE1BQU07c0JBQWQsS0FBSztnQkFHSSxTQUFTO3NCQUFsQixNQUFNO2dCQUdHLEtBQUs7c0JBQWQsTUFBTTtnQkFFZ0MsUUFBUTtzQkFBOUMsU0FBUzt1QkFBQyxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUVELEtBQUs7c0JBQXhDLFlBQVk7dUJBQUMsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBBZnRlclZpZXdJbml0LFxyXG4gIEFmdGVyVmlld0NoZWNrZWQsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBPbkNoYW5nZXMsXHJcbiAgVmlld0NoaWxkLFxyXG4gIFZpZXdDaGlsZHJlbixcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG4gIE5nWm9uZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIFF1ZXJ5TGlzdCxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7XHJcbiAgZnJvbSxcclxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcclxuICBmcm9tRXZlbnQsXHJcbiAgbWVyZ2VNYXAsXHJcbiAgc3RhcnRXaXRoLFxyXG4gIHRhcCxcclxuICBkZWJvdW5jZVRpbWUsXHJcbiAgZmlsdGVyLFxyXG4gIHRha2VVbnRpbCxcclxuICBzd2l0Y2hNYXAsXHJcbiAgT2JzZXJ2YWJsZSxcclxuICBTdWJqZWN0LFxyXG4gIFN1YnNjcmliZXIsXHJcbiAgRU1QVFksXHJcbiAgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXJcclxufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgR2FsbGVyeSB9IGZyb20gJy4uL3NlcnZpY2VzL2dhbGxlcnkuc2VydmljZSc7XHJcbmltcG9ydCB7IEdhbGxlcnlTdGF0ZSwgR2FsbGVyeUVycm9yIH0gZnJvbSAnLi4vbW9kZWxzL2dhbGxlcnkubW9kZWwnO1xyXG5pbXBvcnQgeyBHYWxsZXJ5Q29uZmlnIH0gZnJvbSAnLi4vbW9kZWxzL2NvbmZpZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNsaWRpbmdEaXJlY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY29uc3RhbnRzJztcclxuaW1wb3J0IHsgU2xpZGVyQWRhcHRlciwgSG9yaXpvbnRhbEFkYXB0ZXIsIFZlcnRpY2FsQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMnO1xyXG5pbXBvcnQgeyBTbW9vdGhTY3JvbGxNYW5hZ2VyIH0gZnJvbSAnLi4vc21vb3RoLXNjcm9sbCc7XHJcbmltcG9ydCB7IHJlc2l6ZU9ic2VydmFibGUgfSBmcm9tICcuLi91dGlscy9yZXNpemUtb2JzZXJ2ZXInO1xyXG5pbXBvcnQgeyBHYWxsZXJ5SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vZ2FsbGVyeS1pdGVtLmNvbXBvbmVudCc7XHJcblxyXG5pbnRlcmZhY2UgU2Nyb2xsT2JzZXJ2ZXIge1xyXG4gIHZhbHVlOiBudW1iZXI7XHJcbiAgYmVoYXZpb3I6IFNjcm9sbEJlaGF2aW9yO1xyXG4gIG9uRW5kOiBGdW5jdGlvbjtcclxufVxyXG5cclxuZGVjbGFyZSBjb25zdCBIYW1tZXI6IGFueTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZ2FsbGVyeS1zbGlkZXInLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8ZGl2ICNzbGlkZXJcclxuICAgICAgICAgY2xhc3M9XCJnLXNsaWRlclwiXHJcbiAgICAgICAgIFthdHRyLmNlbnRyYWxpc2VkXT1cImNvbmZpZy5pdGVtQXV0b3NpemVcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImctc2xpZGVyLWNvbnRlbnRcIj5cclxuICAgICAgICA8Z2FsbGVyeS1pdGVtICpuZ0Zvcj1cImxldCBpdGVtIG9mIHN0YXRlLml0ZW1zOyB0cmFja0J5OiB0cmFja0J5Rm47IGluZGV4IGFzIGlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW2F0dHIuZ2FsbGVyeUlkXT1cImdhbGxlcnlJZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJpdGVtLnR5cGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW2NvbmZpZ109XCJjb25maWdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW2RhdGFdPVwiaXRlbS5kYXRhXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFtjdXJySW5kZXhdPVwic3RhdGUuY3VyckluZGV4XCJcclxuICAgICAgICAgICAgICAgICAgICAgIFtpbmRleF09XCJpXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFtjb3VudF09XCJzdGF0ZS5pdGVtcy5sZW5ndGhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIml0ZW1DbGljay5lbWl0KGkpXCJcclxuICAgICAgICAgICAgICAgICAgICAgIChlcnJvcik9XCJlcnJvci5lbWl0KHsgaXRlbUluZGV4OiBpLCBlcnJvcjogJGV2ZW50IH0pXCI+XHJcbiAgICAgICAgPC9nYWxsZXJ5LWl0ZW0+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAgYCxcclxuICBzdGFuZGFsb25lOiB0cnVlLFxyXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEdhbGxlcnlJdGVtQ29tcG9uZW50XVxyXG59KVxyXG5leHBvcnQgY2xhc3MgR2FsbGVyeVNsaWRlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBBZnRlclZpZXdDaGVja2VkLCBPbkRlc3Ryb3kge1xyXG5cclxuICByZWFkb25seSBzY3JvbGxIYW5kbGVyJDogU3ViamVjdDxTY3JvbGxPYnNlcnZlcj4gPSBuZXcgU3ViamVjdDxTY3JvbGxPYnNlcnZlcj4oKTtcclxuXHJcbiAgLyoqIEhhbW1lckpTIGluc3RhbmNlICovXHJcbiAgcHJpdmF0ZSBfaGFtbWVyOiBhbnk7XHJcblxyXG4gIHByaXZhdGUgaW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyO1xyXG5cclxuICBwcml2YXRlIHZpc2libGVFbGVtZW50czogTWFwPEVsZW1lbnQsIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk+ID0gbmV3IE1hcDxFbGVtZW50LCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5PigpO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IF9kZXN0cm95ZWQkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgcHJpdmF0ZSBfaXNQYW5uaW5nOiBib29sZWFuO1xyXG5cclxuICAvKiogU2xpZGVyIGFkYXB0ZXIgKi9cclxuICBhZGFwdGVyOiBTbGlkZXJBZGFwdGVyO1xyXG5cclxuICAvKiogR2FsbGVyeSBJRCAqL1xyXG4gIEBJbnB1dCgpIGdhbGxlcnlJZDogc3RyaW5nO1xyXG5cclxuICAvKiogR2FsbGVyeSBzdGF0ZSAqL1xyXG4gIEBJbnB1dCgpIHN0YXRlOiBHYWxsZXJ5U3RhdGU7XHJcblxyXG4gIC8qKiBHYWxsZXJ5IGNvbmZpZyAqL1xyXG4gIEBJbnB1dCgpIGNvbmZpZzogR2FsbGVyeUNvbmZpZztcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gaXRlbSBpcyBjbGlja2VkICovXHJcbiAgQE91dHB1dCgpIGl0ZW1DbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBhbiBlcnJvciBvY2N1cnMgKi9cclxuICBAT3V0cHV0KCkgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyPEdhbGxlcnlFcnJvcj4oKTtcclxuXHJcbiAgQFZpZXdDaGlsZCgnc2xpZGVyJywgeyBzdGF0aWM6IHRydWUgfSkgc2xpZGVyRWw6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG5cclxuICBAVmlld0NoaWxkcmVuKEdhbGxlcnlJdGVtQ29tcG9uZW50KSBpdGVtcyA9IG5ldyBRdWVyeUxpc3Q8R2FsbGVyeUl0ZW1Db21wb25lbnQ+KCk7XHJcblxyXG4gIGdldCBzbGlkZXIoKTogSFRNTEVsZW1lbnQge1xyXG4gICAgcmV0dXJuIHRoaXMuc2xpZGVyRWwubmF0aXZlRWxlbWVudDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcclxuICAgICAgICAgICAgICBwcml2YXRlIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lLFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX3BsYXRmb3JtOiBQbGF0Zm9ybSxcclxuICAgICAgICAgICAgICBwcml2YXRlIF9zbW9vdGhTY3JvbGw6IFNtb290aFNjcm9sbE1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfZ2FsbGVyeTogR2FsbGVyeSkge1xyXG5cclxuICAgIHRoaXMuc2Nyb2xsSGFuZGxlciQucGlwZShcclxuICAgICAgZGVib3VuY2VUaW1lKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSxcclxuICAgICAgc3dpdGNoTWFwKCh7IHZhbHVlLCBiZWhhdmlvciB9OiBTY3JvbGxPYnNlcnZlcikgPT4ge1xyXG4gICAgICAgIHRoaXMuX2dhbGxlcnkuZGVidWdDb25zb2xlKCdbR2FsbGVyeSBzY3JvbGxIYW5kbGVyJF0gJywgdGhpcy5zbGlkZXIuc3R5bGUuc2Nyb2xsU25hcFR5cGUpO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJ3Vuc2V0JztcclxuICAgICAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgPSB0aGlzLml0ZW1zLmdldCh2YWx1ZSk/LmVsZW1lbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuX2dhbGxlcnkuZGVidWdDb25zb2xlKCfwn6SvIFtHYWxsZXJ5IHNjcm9sbEhhbmRsZXIkXSBzY3JvbGxTbmFwVHlwZSA9IHVuc2V0LCBzY3JvbGxUbyBlbGVtZW50JywgISFlbCk7XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICB0aGlzLnNsaWRlci5jbGFzc0xpc3QuYWRkKCdnLXNjcm9sbGluZycpO1xyXG4gICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5hZGFwdGVyLmdldFNjcm9sbFRvVmFsdWUoZWwsIGJlaGF2aW9yIHx8IHRoaXMuY29uZmlnLnNjcm9sbEJlaGF2aW9yKTtcclxuICAgICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSArdGhpcy5pdGVtcy5nZXQodmFsdWUpPy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZ2FsbGVyeUluZGV4Jyk7XHJcbiAgICAgICAgICB0aGlzLl9nYWxsZXJ5LmRlYnVnQ29uc29sZShg8J+agCBbR2FsbGVyeSBzY3JvbGxIYW5kbGVyJF0gU2Nyb2xsIHN0YXJ0ID09PT4gaW5kZXg6ICR7IGluZGV4IH0sIHBvc2l0aW9uOmAsIHBvcyk7XHJcbiAgICAgICAgICB0aGlzLl9nYWxsZXJ5LmRlYnVnQ29uc29sZShg8J+agCBbR2FsbGVyeSBzY3JvbGxIYW5kbGVyJF0gc2xpZGVyIHNjcm9sbGFibGVgLCB0aGlzLmFkYXB0ZXIuc2Nyb2xsVmFsdWUpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBmcm9tKHRoaXMuX3Ntb290aFNjcm9sbC5zY3JvbGxUbyh0aGlzLnNsaWRlciwgcG9zKSkucGlwZShcclxuICAgICAgICAgICAgdGFwKCgpID0+IHtcclxuICAgICAgICAgICAgICAvLyBSZXNldCB2aWV3cG9ydCBwcm9wZXJ0aWVzIG9uIHNjcm9sbCBlbmRcclxuICAgICAgICAgICAgICB0aGlzLl9pc1Bhbm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICB0aGlzLnNsaWRlci5jbGFzc0xpc3QucmVtb3ZlKCdnLXNjcm9sbGluZycpO1xyXG4gICAgICAgICAgICAgIHRoaXMuc2xpZGVyLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gdGhpcy5hZGFwdGVyLnNjcm9sbFNuYXBUeXBlO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2dhbGxlcnkuZGVidWdDb25zb2xlKCfinIUgW0dhbGxlcnkgc2Nyb2xsSGFuZGxlciRdIFNjcm9sbCBlbmQnKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dhbGxlcnkuZGVidWdDb25zb2xlKCfwn5ihIFtHYWxsZXJ5IHNjcm9sbEhhbmRsZXIkXSBTY3JvbGwgZWxlbWVudCB3YXMgbm90IGZvdW5kIScpO1xyXG4gICAgICAgIHJldHVybiBFTVBUWTtcclxuICAgICAgfSksXHJcbiAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQkKVxyXG4gICAgKS5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmIChjaGFuZ2VzLmNvbmZpZykge1xyXG4gICAgICBpZiAoY2hhbmdlcy5jb25maWcuY3VycmVudFZhbHVlPy5zbGlkaW5nRGlyZWN0aW9uICE9PSBjaGFuZ2VzLmNvbmZpZy5wcmV2aW91c1ZhbHVlPy5zbGlkaW5nRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbmZpZy5zbGlkaW5nRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFNsaWRpbmdEaXJlY3Rpb24uSG9yaXpvbnRhbDpcclxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3IEhvcml6b250YWxBZGFwdGVyKHRoaXMuc2xpZGVyLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBTbGlkaW5nRGlyZWN0aW9uLlZlcnRpY2FsOlxyXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgVmVydGljYWxBZGFwdGVyKHRoaXMuc2xpZGVyLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XHJcbiAgICAgICAgICBpZiAoIWNoYW5nZXMuY29uZmlnLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgY29ycmVjdCBzbGlkaW5nIHBvc2l0aW9uIHdoZW4gZGlyZWN0aW9uIGNoYW5nZXNcclxuICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgodGhpcy5zdGF0ZS5jdXJySW5kZXgsICdhdXRvJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUmVhY3RpdmF0ZSBnZXN0dXJlc1xyXG4gICAgICAgICAgdGhpcy5lbmFibGVEaXNhYmxlR2VzdHVyZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIgJiYgIWNoYW5nZXMuY29uZmlnLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuY29uZmlnLmN1cnJlbnRWYWx1ZT8ubW91c2VTbGlkaW5nRGlzYWJsZWQgIT09IGNoYW5nZXMuY29uZmlnLnByZXZpb3VzVmFsdWU/Lm1vdXNlU2xpZGluZ0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmVuYWJsZURpc2FibGVHZXN0dXJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjcm9sbCB0byBjdXJyZW50IGluZGV4XHJcbiAgICBpZiAodGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyICYmIGNoYW5nZXMuc3RhdGUgJiYgY2hhbmdlcy5zdGF0ZS5jdXJyZW50VmFsdWU/LmN1cnJJbmRleCAhPT0gY2hhbmdlcy5zdGF0ZS5wcmV2aW91c1ZhbHVlPy5jdXJySW5kZXgpIHtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgodGhpcy5zdGF0ZS5jdXJySW5kZXgsIGNoYW5nZXMuc3RhdGUuZmlyc3RDaGFuZ2UgPyAnYXV0bycgOiB0aGlzLnN0YXRlLmJlaGF2aW9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcclxuICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgdGhlIHZpc2libGVFbGVtZW50cyBpbiB0aGUgdmlld3BvcnQgdXNpbmcgaW50ZXJzZWN0aW9uIG9ic2VydmVyXHJcbiAgICAgICAgdGhpcy5jcmVhdGVJbnRlcnNlY3Rpb25PYnNlcnZlcih0aGlzLnNsaWRlcikucGlwZShcclxuICAgICAgICAgIHRhcCgoZW50cnk6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpID0+IHtcclxuICAgICAgICAgICAgZW50cnkudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ2ctaXRlbS12aXNpYmxlJywgZW50cnkuaXNJbnRlcnNlY3RpbmcpO1xyXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcclxuICAgICAgICAgICAgICB0aGlzLnZpc2libGVFbGVtZW50cy5zZXQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy52aXNpYmxlRWxlbWVudHMuZGVsZXRlKGVudHJ5LnRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCQpXHJcbiAgICAgICAgKS5zdWJzY3JpYmUoKTtcclxuXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHNsaWRlciBzY3JvbGwgZXZlbnRcclxuICAgICAgICBmcm9tRXZlbnQodGhpcy5zbGlkZXIsICdzY3JvbGwnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgICAgIGRlYm91bmNlVGltZSg1MCksXHJcbiAgICAgICAgICBmaWx0ZXIoKCkgPT4gIXRoaXMuX2lzUGFubmluZyksXHJcbiAgICAgICAgICB0YXAoKCkgPT4gdGhpcy5vblZpZXdwb3J0U2Nyb2xsKCkpLFxyXG4gICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCQpXHJcbiAgICAgICAgKS5zdWJzY3JpYmUoKTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZWN0IGlmIHRoZSBzaXplIG9mIHRoZSBzbGlkZXIgaGFzIGNoYW5nZWQgZGV0ZWN0aW5nIGN1cnJlbnQgaW5kZXggb24gc2Nyb2xsXHJcbiAgICAgICAgcmVzaXplT2JzZXJ2YWJsZSh0aGlzLl9lbC5uYXRpdmVFbGVtZW50KS5waXBlKFxyXG4gICAgICAgICAgZGVib3VuY2VUaW1lKHRoaXMuY29uZmlnLnJlc2l6ZURlYm91bmNlVGltZSksXHJcbiAgICAgICAgICB0YXAoKFtlbnRyeV06IFJlc2l6ZU9ic2VydmVyRW50cnlbXSkgPT4gdGhpcy5vbkhvc3RSZXNpemUoZW50cnkpKSxcclxuICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQkKVxyXG4gICAgICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xyXG4gICAgICB0aGlzLml0ZW1zLm5vdGlmeU9uQ2hhbmdlcygpO1xyXG4gICAgICB0aGlzLml0ZW1zLmNoYW5nZXMucGlwZShcclxuICAgICAgICBzdGFydFdpdGgobnVsbCksXHJcbiAgICAgICAgdGFwKCgpID0+IHtcclxuICAgICAgICAgIC8vIERpc2Nvbm5lY3QgYWxsIGFuZCByZWNvbm5lY3QgbGF0ZXJcclxuICAgICAgICAgIHRoaXMudmlzaWJsZUVsZW1lbnRzLmZvckVhY2goKGl0ZW06IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci51bm9ic2VydmUoaXRlbS50YXJnZXQpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQ29ubmVjdCB3aXRoIHRoZSBuZXcgaXRlbXNcclxuICAgICAgICAgIHRoaXMuaXRlbXMudG9BcnJheSgpLm1hcCgoaXRlbTogR2FsbGVyeUl0ZW1Db21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKGl0ZW0uZWxlbWVudCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KSxcclxuICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkJClcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZy5pdGVtQXV0b3NpemUgJiYgdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XHJcbiAgICAgIHRoaXMuc2xpZGVyLnN0eWxlLnNldFByb3BlcnR5KCctLXNsaWRlci1jZW50cmFsaXplLXN0YXJ0LXNpemUnLCB0aGlzLmFkYXB0ZXIuZ2V0Q2VudHJhbGl6ZXJTdGFydFNpemUoKSArICdweCcpO1xyXG4gICAgICB0aGlzLnNsaWRlci5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zbGlkZXItY2VudHJhbGl6ZS1lbmQtc2l6ZScsIHRoaXMuYWRhcHRlci5nZXRDZW50cmFsaXplckVuZFNpemUoKSArICdweCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kZXN0cm95ZWQkLm5leHQoKTtcclxuICAgIHRoaXMuX2Rlc3Ryb3llZCQuY29tcGxldGUoKTtcclxuICAgIHRoaXMuZGVhY3RpdmF0ZUdlc3R1cmVzKCk7XHJcbiAgfVxyXG5cclxuICB0cmFja0J5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogYW55KSB7XHJcbiAgICByZXR1cm4gaXRlbS50eXBlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBvbkhvc3RSZXNpemUoZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IHdpZHRoOiBudW1iZXIgPSBNYXRoLmNlaWwoZW50cnkuY29udGVudFJlY3Qud2lkdGgpO1xyXG4gICAgY29uc3QgaGVpZ2h0OiBudW1iZXIgPSBNYXRoLmNlaWwoZW50cnkuY29udGVudFJlY3QuaGVpZ2h0KTtcclxuICAgIHRoaXMuc2xpZGVyLnN0eWxlLndpZHRoID0gYCR7IHdpZHRoIH1weGA7XHJcbiAgICB0aGlzLnNsaWRlci5zdHlsZS5oZWlnaHQgPSBgJHsgaGVpZ2h0IH1weGA7XHJcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXgodGhpcy5zdGF0ZS5jdXJySW5kZXgsICdhdXRvJyk7XHJcbiAgICAvLyBEZXRlY3QgY2hhbmdlcyBvbiBnYWxsZXJ5LWl0ZW0gY29tcG9uZW50cyB0byByZS1jYWxjdWxhdGUgaXRlbSBzaXplXHJcbiAgICB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgICB0aGlzLl9nYWxsZXJ5LmRlYnVnQ29uc29sZSgn8J+mkCBbR2FsbGVyeSBPbkhvc3RSZXNpemVdOiBzZXQgdmlld3BvcnQgd2lkdGggdG8gYWJzb2x1dGUgbnVtYmVyJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uVmlld3BvcnRTY3JvbGwoKTogdm9pZCB7XHJcbiAgICAvLyBDaGVjayBpZiBzY3JvbGxlZCBpdGVtIGlzIGdyZWF0IGVub3VnaCB0byBuYXZpZ2F0ZVxyXG4gICAgY29uc3QgY3VyckVsZW1lbnQ6IEVsZW1lbnQgPSB0aGlzLml0ZW1zLmdldCh0aGlzLnN0YXRlLmN1cnJJbmRleCk/LmVsZW1lbnQ7XHJcbiAgICBjb25zdCBlbGVtZW50QXRDZW50ZXI6IEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnRGcm9tVmlld3BvcnRDZW50ZXIoKTtcclxuXHJcbiAgICBpZiAoZWxlbWVudEF0Q2VudGVyKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBnYWxsZXJ5LWl0ZW0gZWxlbWVudCBpcyBub3QgdGhlIGFjdGl2ZSBlbGVtZW50XHJcbiAgICAgIGlmIChlbGVtZW50QXRDZW50ZXIgIT09IGN1cnJFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy50cnlTY3JvbGxUb0VsZW1lbnQoZWxlbWVudEF0Q2VudGVyIGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZ2FsbGVyeS5kZWJ1Z0NvbnNvbGUoJ+KBiSBbR2FsbGVyeSBvblZpZXdwb3J0U2Nyb2xsXTogTm8gY2VudGVyIGVsZW1lbnQgd2FzIGZvdW5kJyk7XHJcbiAgICAgIHRoaXMudmlzaWJsZUVsZW1lbnRzLmZvckVhY2goKGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KSA9PiB7XHJcbiAgICAgICAgdGhpcy50cnlTY3JvbGxUb0VsZW1lbnQoZW50cnkudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHRyeVNjcm9sbFRvRWxlbWVudChlbGVtZW50QXRDZW50ZXI6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICBjb25zdCBhbGxvd2VkTWFyZ2luOiBudW1iZXIgPSAxMDtcclxuICAgIGNvbnN0IG9mZnNldERpZmY6IG51bWJlciA9ICh0aGlzLmFkYXB0ZXIuY2xpZW50U2l6ZSAtIHRoaXMuYWRhcHRlci5nZXRDbGllbnRTaXplKGVsZW1lbnRBdENlbnRlcikpIC8gMjtcclxuICAgIGNvbnN0IHJhbmdlU3RhcnQ6IG51bWJlciA9IHRoaXMuYWRhcHRlci5zY3JvbGxWYWx1ZSArIG9mZnNldERpZmY7XHJcbiAgICBjb25zdCByYW5nZUVuZDogbnVtYmVyID0gdGhpcy5hZGFwdGVyLnNjcm9sbFZhbHVlICsgdGhpcy5hZGFwdGVyLmNsaWVudFNpemUgLSBvZmZzZXREaWZmO1xyXG4gICAgY29uc3QgZWxTdGFydDogbnVtYmVyID0gdGhpcy5hZGFwdGVyLmdldE9mZnNldFNpemUoZWxlbWVudEF0Q2VudGVyKTtcclxuICAgIGNvbnN0IGVsRW5kOiBudW1iZXIgPSBlbFN0YXJ0ICsgdGhpcy5hZGFwdGVyLmdldENsaWVudFNpemUoZWxlbWVudEF0Q2VudGVyKTtcclxuXHJcbiAgICBjb25zdCBpc1N0YXJ0OiBib29sZWFuID0gcmFuZ2VTdGFydCArIGFsbG93ZWRNYXJnaW4gPj0gZWxTdGFydCAmJiByYW5nZVN0YXJ0IC0gYWxsb3dlZE1hcmdpbiA8PSBlbFN0YXJ0O1xyXG4gICAgY29uc3QgaXNFbmQ6IGJvb2xlYW4gPSByYW5nZUVuZCArIGFsbG93ZWRNYXJnaW4gPj0gZWxFbmQgJiYgcmFuZ2VFbmQgLSBhbGxvd2VkTWFyZ2luIDw9IGVsRW5kO1xyXG5cclxuICAgIC8vIFJlc2V0IHBvc2l0aW9uXHJcbiAgICB0aGlzLnNsaWRlci5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IHRoaXMuYWRhcHRlci5zY3JvbGxTbmFwVHlwZTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIHdpdGhpbiB0aGUgZGV0ZWN0aW9uIHJhbmdlXHJcbiAgICBpZiAoaXNTdGFydCAmJiBpc0VuZCkge1xyXG4gICAgICAvLyBJZiBlbGVtZW50IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGl0IGFzIHRoZSBhY3RpdmUgZ2FsbGVyeSBpdGVtXHJcbiAgICAgIHRoaXMuX2dhbGxlcnkuZGVidWdDb25zb2xlKCfwn42EIFtHYWxsZXJ5IG9uVmlld3BvcnRTY3JvbGxdOiBTZXQgYWN0aXZlIGdhbGxlcnkgaXRlbScpO1xyXG5cclxuICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9ICtlbGVtZW50QXRDZW50ZXIuZ2V0QXR0cmlidXRlKCdnYWxsZXJ5SW5kZXgnKTtcclxuICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4gdGhpcy5fZ2FsbGVyeS5yZWYodGhpcy5nYWxsZXJ5SWQpLnNldChpbmRleCwgJ3Ntb290aCcpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2Nyb2xsVG9JbmRleCh2YWx1ZTogbnVtYmVyLCBiZWhhdmlvcjogU2Nyb2xsQmVoYXZpb3IsIG9uRW5kPzogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyJC5uZXh0KHsgdmFsdWUsIGJlaGF2aW9yLCBvbkVuZCB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW5hYmxlRGlzYWJsZUdlc3R1cmVzKCk6IHZvaWQge1xyXG4gICAgLy8gRW5hYmxlL0Rpc2FibGUgbW91c2Ugc2xpZGluZyBvbiBkZXNrdG9wIGJyb3dzZXIgb25seVxyXG4gICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5JT1MgJiYgIXRoaXMuX3BsYXRmb3JtLkFORFJPSUQpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5tb3VzZVNsaWRpbmdEaXNhYmxlZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGVHZXN0dXJlcygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUdlc3R1cmVzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWN0aXZhdGVHZXN0dXJlcygpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2YgSGFtbWVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAvLyBEZXN0cm95IGhhbW1lciBpZiBhIHByZXZpb3VzIGluc3RhbmNlIHdhcyBjcmVhdGVkXHJcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZUdlc3R1cmVzKCk7XHJcblxyXG4gICAgICBjb25zdCBkaXJlY3Rpb246IG51bWJlciA9IHRoaXMuYWRhcHRlci5wYW5EaXJlY3Rpb247XHJcblxyXG4gICAgICAvLyBBY3RpdmF0ZSBnZXN0dXJlc1xyXG4gICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICB0aGlzLl9oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsIHsgaW5wdXRDbGFzczogSGFtbWVyLk1vdXNlSW5wdXQgfSk7XHJcbiAgICAgICAgdGhpcy5faGFtbWVyLmdldCgncGFuJykuc2V0KHsgZGlyZWN0aW9uIH0pO1xyXG5cclxuICAgICAgICBsZXQgcGFuT2Zmc2V0OiBudW1iZXI7XHJcblxyXG4gICAgICAgIC8vIFNldCBwYW5PZmZzZXQgZm9yIHNsaWRpbmcgb24gcGFuIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgdGhpcy5faGFtbWVyLm9uKCdwYW5zdGFydCcsICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3Ntb290aFNjcm9sbC5kaXNtaXNzT25nb2luZ1Njcm9sbCh0aGlzLnNsaWRlcik7XHJcbiAgICAgICAgICBwYW5PZmZzZXQgPSB0aGlzLmFkYXB0ZXIuc2Nyb2xsVmFsdWU7XHJcbiAgICAgICAgICAvLyBEaXNhYmxlIHNjcm9sbC1zbmFwLXR5cGUgZnVuY3Rpb25hbGl0eVxyXG4gICAgICAgICAgdGhpcy5zbGlkZXIuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAndW5zZXQnO1xyXG4gICAgICAgICAgdGhpcy5zbGlkZXIuY2xhc3NMaXN0LmFkZCgnZy1zbGlkaW5nJyk7XHJcbiAgICAgICAgICB0aGlzLl9pc1Bhbm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9oYW1tZXIub24oJ3Bhbm1vdmUnLCAoZTogYW55KSA9PiB0aGlzLnNsaWRlci5zY3JvbGxUbyh0aGlzLmFkYXB0ZXIuZ2V0UGFuVmFsdWUocGFuT2Zmc2V0LCBlLCAnYXV0bycpKSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbW1lci5vbigncGFuZW5kJywgKGU6IGFueSkgPT4gdGhpcy5vblBhbkVuZChlKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkZWFjdGl2YXRlR2VzdHVyZXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9oYW1tZXI/LmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBvblBhbkVuZChlKTogdm9pZCB7XHJcblxyXG4gICAgdGhpcy5fZ2FsbGVyeS5kZWJ1Z0NvbnNvbGUoJ/CflrHvuI8gW0dhbGxlcnldOiBvblBhbkVuZCcsIGUpO1xyXG5cclxuICAgIHRoaXMuc2xpZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2ctc2xpZGluZycpO1xyXG4gICAgY29uc3QgZGVsdGE6IG51bWJlciA9IHRoaXMuYWRhcHRlci5nZXRQYW5EZWx0YShlKTtcclxuICAgIGNvbnN0IHZlbG9jaXR5OiBudW1iZXIgPSB0aGlzLmFkYXB0ZXIuZ2V0UGFuVmVsb2NpdHkoZSk7XHJcblxyXG4gICAgY29uc3QgZ2FsbGVyeVJlZiA9IHRoaXMuX2dhbGxlcnkucmVmKHRoaXMuZ2FsbGVyeUlkKTtcclxuXHJcbiAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHNjcm9sbGVkIGl0ZW0gaXMgZ3JlYXQgZW5vdWdoIHRvIG5hdmlnYXRlXHJcbiAgICAgIGNvbnN0IGN1cnJFbGVtZW50OiBFbGVtZW50ID0gdGhpcy5pdGVtcy5nZXQodGhpcy5zdGF0ZS5jdXJySW5kZXgpPy5lbGVtZW50O1xyXG5cclxuICAgICAgLy8gRmluZCB0aGUgZ2FsbGVyeSBpdGVtIGVsZW1lbnQgaW4gdGhlIGNlbnRlciBlbGVtZW50c1xyXG4gICAgICBjb25zdCBlbGVtZW50QXRDZW50ZXI6IEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnRGcm9tVmlld3BvcnRDZW50ZXIoKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGNlbnRlciBpdGVtIGNhbiBiZSB0YWtlbiBmcm9tIGVsZW1lbnQgdXNpbmdcclxuICAgICAgaWYgKGVsZW1lbnRBdENlbnRlciAmJiBlbGVtZW50QXRDZW50ZXIgIT09IGN1cnJFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9ICtlbGVtZW50QXRDZW50ZXIuZ2V0QXR0cmlidXRlKCdnYWxsZXJ5SW5kZXgnKTtcclxuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgoaW5kZXgsICdzbW9vdGgnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGRlbHRhIGlzIGdyZWF0IGVub3VnaCB0byBuYXZpZ2F0ZVxyXG4gICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKGN1cnJFbGVtZW50LmNsaWVudFdpZHRoIHx8IHRoaXMuYWRhcHRlci5jbGllbnRTaXplKSAvIDIpIHtcclxuICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gZ2FsbGVyeVJlZi5wcmV2KCdzbW9vdGgnLCBmYWxzZSkgOiBnYWxsZXJ5UmVmLm5leHQoJ3Ntb290aCcsIGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdmVsb2NpdHkgaXMgZ3JlYXQgZW5vdWdoIHRvIG5hdmlnYXRlXHJcbiAgICAgIGlmIChNYXRoLmFicyh2ZWxvY2l0eSkgPiAwLjMpIHtcclxuICAgICAgICByZXR1cm4gdmVsb2NpdHkgPiAwID8gZ2FsbGVyeVJlZi5wcmV2KCdzbW9vdGgnLCBmYWxzZSkgOiBnYWxsZXJ5UmVmLm5leHQoJ3Ntb290aCcsIGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gdG8gdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KHRoaXMuc3RhdGUuY3VyckluZGV4LCAnc21vb3RoJyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RWxlbWVudEZyb21WaWV3cG9ydENlbnRlcigpOiBFbGVtZW50IHtcclxuICAgIC8vIEdldCBzbGlkZXIgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XHJcbiAgICBjb25zdCBzbGlkZXJSZWN0ID0gdGhpcy5zbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAvLyBUcnkgbG9vayBmb3IgdGhlIGNlbnRlciBpdGVtIHVzaW5nIGBlbGVtZW50c0Zyb21Qb2ludGAgZnVuY3Rpb25cclxuICAgIGNvbnN0IGNlbnRlckVsZW1lbnRzID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoc2xpZGVyUmVjdC54ICsgKHNsaWRlclJlY3Qud2lkdGggLyAyKSwgc2xpZGVyUmVjdC55ICsgKHNsaWRlclJlY3QuaGVpZ2h0IC8gMikpO1xyXG4gICAgLy8gRmluZCB0aGUgZ2FsbGVyeSBpdGVtIGVsZW1lbnQgaW4gdGhlIGNlbnRlciBlbGVtZW50c1xyXG4gICAgY29uc3QgZWxlbWVudCA9IGNlbnRlckVsZW1lbnRzLmZpbmQoKGVsZW1lbnQ6IEVsZW1lbnQpID0+IGVsZW1lbnQubG9jYWxOYW1lID09PSAnZ2FsbGVyeS1pdGVtJyAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZ2FsbGVyeUlkJykgPT09IHRoaXMuZ2FsbGVyeUlkKTtcclxuXHJcbiAgICB0aGlzLl9nYWxsZXJ5LmRlYnVnQ29uc29sZSgn8J+qnyBbR2FsbGVyeV06IGdldEVsZW1lbnRGcm9tVmlld3BvcnRDZW50ZXInLCBlbGVtZW50KTtcclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVJbnRlcnNlY3Rpb25PYnNlcnZlcihzbGlkZXI6IEhUTUxFbGVtZW50KTogT2JzZXJ2YWJsZTxJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5PiB7XHJcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyOiBTdWJzY3JpYmVyPEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlbXT4pID0+IHtcclxuICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcclxuICAgICAgICAoZW50cmllczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeVtdKSA9PiBvYnNlcnZlci5uZXh0KGVudHJpZXMpLFxyXG4gICAgICAgIHsgcm9vdDogc2xpZGVyIH1cclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuICgpID0+IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgfSkucGlwZShcclxuICAgICAgbWVyZ2VNYXAoKGVudHJpZXM6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlbXSkgPT4gZW50cmllcyksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXX0=